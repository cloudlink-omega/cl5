// CL5
// ID: cl5
// Description: CloudLink 5 protocol extension. Unleash your potential.
// By: MikeDEV
// License: MIT

(() => {
  // src/index.ts
  var PeerConnection = class extends RTCPeerConnection {
    user;
    channelIdCounter;
    hasPublicKey;
    constructor(configuration) {
      super(configuration);
    }
  };
  (function(Scratch2) {
    if (!Scratch2.extensions.unsandboxed) {
      throw new Error("Sandboxed mode is not supported in this extension.");
    }
    const infoBlurb = "This comment is auto-generated by the CL5 extension. Do NOT manually edit this comment, as it can cause problems restoring your networked variables/lists! However, you are free resize or minimize this comment, and you can simply delete this comment to reset the extension.\n\n";
    const configEnd = "// _clconfig_";
    function uid() {
      const soup_ = "!#%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      const length = 20;
      const soupLength = soup_.length;
      const id = [];
      for (let i = 0; i < length; i++) {
        id[i] = soup_.charAt(Math.random() * soupLength);
      }
      return id.join("");
    }
    function makeValueSafeForScratch(data) {
      try {
        if (typeof data === "string") {
          return data;
        } else if (typeof data === "object" && data !== null) {
          return JSON.stringify(data);
        } else {
          return data.toString();
        }
      } catch (error) {
        console.error(`Error making data ${data} vm-safe: ${error}`);
        return data.toString();
      }
    }
    class OmegaEncryption {
      // Define types
      secrets;
      // Store derived key secrets (remotePeerId: sharedKey)
      keyPair;
      // ECDH P-256 key pair (public: spki, private: pkcs8)
      constructor() {
        this.secrets = /* @__PURE__ */ new Map();
        this.keyPair = null;
      }
      async generateKeyPair() {
        if (this.keyPair) {
          console.warn("Key pair already exists");
          return null;
        }
        this.keyPair = await window.crypto.subtle.generateKey(
          {
            name: "ECDH",
            namedCurve: "P-256"
          },
          true,
          ["deriveKey", "deriveBits"]
        );
        return this.keyPair;
      }
      async exportPublicKey() {
        if (!this.keyPair) {
          console.warn("Key pair does not exist");
          return null;
        }
        const exportedKey = await window.crypto.subtle.exportKey(
          "spki",
          this.keyPair.publicKey
        );
        return this.arrayBufferToBase64(new Uint8Array(exportedKey));
      }
      async importPublicKey(exportedKey) {
        const exportedKeyArray = this.base64ToArrayBuffer(exportedKey);
        const publicKey = await window.crypto.subtle.importKey(
          "spki",
          exportedKeyArray,
          {
            name: "ECDH",
            namedCurve: "P-256"
          },
          true,
          []
        );
        return publicKey;
      }
      async deriveSharedKey(publicKey, privateKey) {
        const sharedKey = await window.crypto.subtle.deriveKey(
          {
            name: "ECDH",
            public: publicKey
          },
          privateKey,
          {
            name: "AES-GCM",
            length: 256
          },
          true,
          ["encrypt", "decrypt"]
        );
        return sharedKey;
      }
      async encryptMessage(message, sharedKey) {
        const encodedMessage = new TextEncoder().encode(message);
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encryptedMessage = await window.crypto.subtle.encrypt(
          {
            name: "AES-GCM",
            iv
          },
          sharedKey,
          encodedMessage
        );
        const encryptedMessageArray = new Uint8Array(encryptedMessage);
        const encryptedMessageBase64 = this.arrayBufferToBase64(
          encryptedMessageArray
        );
        const ivBase64 = this.arrayBufferToBase64(iv);
        return { encryptedMessage: encryptedMessageBase64, iv: ivBase64 };
      }
      async decryptMessage(encryptedMessageBase64, ivBase64, sharedKey) {
        const encryptedMessageArray = this.base64ToArrayBuffer(
          encryptedMessageBase64
        );
        const iv = this.base64ToArrayBuffer(ivBase64);
        const decryptedMessage = await window.crypto.subtle.decrypt(
          {
            name: "AES-GCM",
            iv
          },
          sharedKey,
          encryptedMessageArray
        );
        const decodedMessage = new TextDecoder().decode(decryptedMessage);
        return decodedMessage;
      }
      arrayBufferToBase64(buffer) {
        let binary = "";
        const bytes = new Uint8Array(buffer);
        for (let i = 0; i < bytes.byteLength; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      }
      base64ToArrayBuffer(base64) {
        const binary_string = window.atob(base64);
        const len = binary_string.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes.buffer;
      }
      setSharedKey(remotePeerId, sharedKey) {
        this.secrets.set(remotePeerId, sharedKey);
      }
      getSharedKey(remotePeerId) {
        return this.secrets.get(remotePeerId);
      }
      setSharedKeyFromPublicKey(remotePeerId, publicKey) {
        return new Promise((resolve, reject) => {
          this.importPublicKey(publicKey).then((pKey) => {
            this.deriveSharedKey(pKey, this.keyPair.privateKey).then((sharedKey) => {
              this.setSharedKey(remotePeerId, sharedKey);
              resolve();
            }).catch((error) => {
              console.error(
                `Error deriving shared key for ${remotePeerId}: ${error}`
              );
              reject();
            });
          }).catch((error) => {
            console.error(
              `Error importing public key for ${remotePeerId}: ${error}`
            );
            reject();
          });
        });
      }
    }
    class OmegaRTC {
      // Define types
      encryption;
      signaling;
      configuration;
      peerConnections;
      voiceConnections;
      dataChannels;
      iceCandidates;
      messageHandlers;
      constructor(encryption, signaling) {
        this.encryption = encryption;
        this.signaling = signaling;
        this.configuration = {
          // Public STUN/TURN servers.
          iceServers: [
            { urls: "stun:vpn.mikedev101.cc:3478" },
            // STUN over TCP/UDP
            {
              urls: "turn:vpn.mikedev101.cc:3478",
              username: "free",
              credential: "free"
            },
            // TURN over TCP/UDP
            { urls: "stun:stun.l.google.com:19302" },
            // STUN over TCP/UDP
            { urls: "stun:freeturn.net:3478" },
            // STUN over TCP/UDP
            { urls: "stun:freeturn.net:5349" },
            // STUN over TCP/UDP
            {
              urls: "turn:freeturn.net:3478",
              username: "free",
              credential: "free"
            },
            // TURN over TCP/UDP
            {
              urls: "turns:freeturn.net:5349",
              username: "free",
              credential: "free"
            }
            // TURN over TLS
          ],
          iceTransportPolicy: "all"
          // Set to 'relay' if you want TURN only.
        };
        this.peerConnections = /* @__PURE__ */ new Map();
        this.voiceConnections = /* @__PURE__ */ new Map();
        this.dataChannels = /* @__PURE__ */ new Map();
        this.iceCandidates = {};
        this.messageHandlers = {
          onIceCandidate: {},
          onIceGatheringDone: {},
          onChannelOpen: {},
          onChannelClose: {},
          onChannelMessage: {}
        };
      }
      getPeers() {
        const output = {};
        const peers = Array.from(this.peerConnections.keys());
        const cons = this.peerConnections;
        Array.from(peers).forEach((ulid) => {
          if (cons.get(ulid).connectionState == "connected")
            output[cons.get(ulid).user] = ulid;
        });
        return output;
      }
      getPeerChannels(remoteUserId) {
        if (!this.doesPeerExist(remoteUserId))
          return [];
        return Array.from(this.dataChannels.get(remoteUserId).keys());
      }
      // Voice channel functions
      async createVoiceOffer(remoteUserId, remoteUserName) {
        const voiceConnection = this.createConnection(
          remoteUserId,
          remoteUserName,
          true
        );
        await this.handleVoiceStream(
          voiceConnection,
          remoteUserId,
          remoteUserName
        );
        try {
          const offer = await voiceConnection.createOffer();
          await voiceConnection.setLocalDescription(offer);
          return offer;
        } catch (error) {
          console.error(
            `Error creating voice offer for ${voiceConnection.user} (${remoteUserId}): ${error}`
          );
          return null;
        }
      }
      async createVoiceAnswer(remoteUserId, remoteUserName, offer) {
        const voiceConnection = this.createConnection(
          remoteUserId,
          remoteUserName,
          true
        );
        await this.handleVoiceStream(
          voiceConnection,
          remoteUserId,
          remoteUserName
        );
        try {
          await voiceConnection.setRemoteDescription(
            new RTCSessionDescription(offer)
          );
          const answer = await voiceConnection.createAnswer();
          await voiceConnection.setLocalDescription(answer);
          return answer;
        } catch (error) {
          console.error(
            `Error creating voice answer for ${voiceConnection.user} (${remoteUserId}): ${error}`
          );
          return null;
        }
      }
      async handleVoiceAnswer(remoteUserId, answer) {
        const voiceConnection = this.voiceConnections.get(remoteUserId);
        if (voiceConnection) {
          try {
            await voiceConnection.setRemoteDescription(
              new RTCSessionDescription(answer)
            );
          } catch (error) {
            console.error(
              `Error handling voice answer for ${voiceConnection.user} (${remoteUserId}): ${error}`
            );
          }
        } else {
          console.error(`Peer voice connection not found for ${remoteUserId}`);
        }
      }
      addVoiceIceCandidate(remoteUserId, iceCandidate) {
        const voiceConnection = this.voiceConnections.get(remoteUserId);
        if (voiceConnection) {
          try {
            const candidate = new RTCIceCandidate(iceCandidate);
            voiceConnection.addIceCandidate(candidate);
          } catch (error) {
            console.error(
              `Error adding voice ice candidate for ${voiceConnection.user} (${remoteUserId}): ${error}`
            );
          }
        } else {
          console.error(`Peer voice connection not found for ${remoteUserId}`);
        }
      }
      isVoiceConnectionOpen(remoteUserId) {
        if (!this.doesPeerExist(remoteUserId)) {
          return false;
        }
        const voiceConnection = this.voiceConnections.get(remoteUserId);
        return voiceConnection != null && // Check if voice connection exists
        voiceConnection.getSenders().length > 0 && // Check if there are senders
        voiceConnection.getSenders()[0].track.readyState === "live";
      }
      isVoiceConnectionMuted(remoteUserId) {
        if (!this.isVoiceConnectionOpen(remoteUserId))
          return false;
        const voiceConnection = this.voiceConnections.get(remoteUserId);
        return voiceConnection.getSenders().length > 0 && // Check if there are senders
        !voiceConnection.getSenders()[0].track.enabled;
      }
      changeMicState(remoteUserId, state) {
        if (!this.isVoiceConnectionOpen(remoteUserId))
          return;
        const voiceConnection = this.voiceConnections.get(remoteUserId);
        const senders = voiceConnection.getSenders();
        for (const s of senders) {
          const t = s.track;
          if (t.kind !== "audio") {
            continue;
          }
          t.enabled = state;
        }
      }
      async createVoiceConnection(remoteUserId) {
        if (!this.doesPeerExist(remoteUserId))
          return;
        if (this.isVoiceConnectionOpen(remoteUserId))
          return;
        const sharedKey = await this.encryption.getSharedKey(remoteUserId);
        const remoteUserName = this.peerConnections.get(remoteUserId).user;
        const offer = await this.createVoiceOffer(remoteUserId, remoteUserName);
        if (sharedKey) {
          const { encryptedMessage, iv } = await this.encryption.encryptMessage(
            JSON.stringify(offer),
            sharedKey
          );
          this.signaling.sendOffer(
            remoteUserId,
            {
              type: 1,
              // voice
              contents: [encryptedMessage, iv]
            },
            null
          );
        } else {
          this.signaling.sendOffer(
            remoteUserId,
            {
              type: 1,
              // voice
              contents: offer
            },
            null
          );
        }
      }
      closeVoiceConnection(remoteUserId) {
        if (!this.doesPeerExist(remoteUserId))
          return;
        const voiceConnection = this.voiceConnections.get(remoteUserId);
        if (!voiceConnection)
          return;
        const senders = voiceConnection.getSenders();
        for (const s of senders) {
          const t = s.track;
          if (t.kind !== "audio")
            continue;
          t.stop();
        }
        voiceConnection.close();
        this.closeVoiceStream(remoteUserId);
      }
      // Data channel functions
      async createDataOffer(remoteUserId, remoteUserName) {
        const peerConnection = this.createConnection(
          remoteUserId,
          remoteUserName,
          false
        );
        this.createDefaultChannel(peerConnection, remoteUserId, remoteUserName);
        try {
          const offer = await peerConnection.createOffer();
          await peerConnection.setLocalDescription(offer);
          return offer;
        } catch (error) {
          console.error(
            `Error creating offer for ${peerConnection.user} (${remoteUserId}): ${error}`
          );
          return null;
        }
      }
      async createDataAnswer(remoteUserId, remoteUserName, offer) {
        const peerConnection = this.createConnection(
          remoteUserId,
          remoteUserName,
          false
        );
        this.createDefaultChannel(peerConnection, remoteUserId, remoteUserName);
        try {
          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(offer)
          );
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          return answer;
        } catch (error) {
          console.error(
            `Error creating answer for ${peerConnection.user} (${remoteUserId}): ${error}`
          );
          return null;
        }
      }
      async handleDataAnswer(remoteUserId, answer) {
        const peerConnection = this.peerConnections.get(remoteUserId);
        if (peerConnection) {
          try {
            await peerConnection.setRemoteDescription(
              new RTCSessionDescription(answer)
            );
          } catch (error) {
            console.error(
              `Error handling answer for ${peerConnection.user} (${remoteUserId}): ${error}`
            );
          }
        } else {
          console.error(`Peer connection not found for ${remoteUserId}`);
        }
      }
      addDataIceCandidate(remoteUserId, iceCandidate) {
        const peerConnection = this.peerConnections.get(remoteUserId);
        if (peerConnection) {
          try {
            const candidate = new RTCIceCandidate(iceCandidate);
            peerConnection.addIceCandidate(candidate);
          } catch (error) {
            console.error(
              `Error adding ice candidate for ${peerConnection.user} (${remoteUserId}): ${error}`
            );
          }
        } else {
          console.error(
            `Peer connection not found for ${peerConnection.user} (${remoteUserId})`
          );
        }
      }
      // Common function for creating peer/voice connections
      createConnection(remoteUserId, remoteUserName, isAudioOnly) {
        const conn = new PeerConnection(this.configuration);
        conn.user = remoteUserName;
        conn.channelIdCounter = 0;
        conn.hasPublicKey = false;
        conn.onicecandidate = (event) => {
          if (event.candidate) {
            if (!this.iceCandidates[remoteUserId]) {
              this.iceCandidates[remoteUserId] = [];
            }
            this.iceCandidates[remoteUserId].push(event.candidate);
            if (this.messageHandlers.onIceCandidate[remoteUserId]) {
              this.messageHandlers.onIceCandidate[remoteUserId](event.candidate);
            }
          }
          if (event.target["iceGatheringState"] === "complete") {
            if (this.messageHandlers.onIceGatheringDone[remoteUserId]) {
              this.messageHandlers.onIceGatheringDone[remoteUserId]();
            }
          }
        };
        if (!isAudioOnly) {
          conn.ondatachannel = (event) => {
            const dataChannel = event.channel;
            this.handleDataChannel(dataChannel, remoteUserId, remoteUserName);
          };
        }
        conn.onconnectionstatechange = () => {
          switch (conn.connectionState) {
            case "new":
              console.log(`Peer ${remoteUserName} (${remoteUserId}) created.`);
              break;
            case "connecting":
              console.log(
                `Peer ${remoteUserName} (${remoteUserId}) connecting...`
              );
              break;
            case "connected":
              console.log(`Peer ${remoteUserName} (${remoteUserId}) connected.`);
              break;
            case "disconnected":
              console.log(
                `Peer ${remoteUserName} (${remoteUserId}) disconnecting...`
              );
              break;
            case "closed":
              console.log(
                `Peer ${remoteUserName} (${remoteUserId}) disconnected.`
              );
              if (isAudioOnly)
                this.closeVoiceStream(remoteUserId);
              else
                this.disconnectDataPeer(remoteUserId);
              break;
            case "failed":
              console.log(
                `Peer ${remoteUserName} (${remoteUserId}) connection failed.`
              );
              if (isAudioOnly)
                this.closeVoiceStream(remoteUserId);
              else
                this.disconnectDataPeer(remoteUserId);
              break;
            default:
              console.log(
                `Peer ${remoteUserName} (${remoteUserId}) connection state unknown.`
              );
              break;
          }
        };
        if (isAudioOnly) {
          conn.ontrack = (event) => {
            console.log(
              `Adding peer ${remoteUserId} audio stream... ${event.streams}`
            );
            for (const stream of event.streams) {
              const audioElement = document.createElement(`audio`);
              audioElement.id = `audio_${remoteUserId}`;
              audioElement.srcObject = stream;
              audioElement.autoplay = true;
              document.body.appendChild(audioElement);
            }
          };
        }
        if (isAudioOnly)
          this.voiceConnections.set(remoteUserId, conn);
        else
          this.peerConnections.set(remoteUserId, conn);
        return conn;
      }
      handleDataChannel(dataChannel, remoteUserId, remoteUserName) {
        const channel = dataChannel;
        if (!this.dataChannels.has(remoteUserId))
          this.dataChannels.set(remoteUserId, /* @__PURE__ */ new Map());
        channel.dataStorage = /* @__PURE__ */ new Map();
        channel.onmessage = (event) => {
          if (this.messageHandlers.onChannelMessage[remoteUserId]) {
            this.messageHandlers.onChannelMessage[remoteUserId](
              event.data,
              channel
            );
          }
        };
        channel.onopen = () => {
          console.log(
            `Data channel ${channel.label} with ${remoteUserName} (${remoteUserId}) opened`
          );
          if (this.messageHandlers.onChannelOpen[remoteUserId]) {
            this.messageHandlers.onChannelOpen[remoteUserId](channel.label);
          }
        };
        channel.onclose = () => {
          console.log(
            `Data channel ${channel.label} with ${remoteUserName} (${remoteUserId}) closed`
          );
          if (channel.label == "default") {
            this.disconnectDataPeer(remoteUserId);
            this.closeVoiceStream(remoteUserId);
          } else {
            this.dataChannels.get(remoteUserId).delete(channel.label);
          }
        };
        this.dataChannels.get(remoteUserId).set(channel.label, channel);
      }
      async handleVoiceStream(voiceConnection, remoteUserId, remoteUserName) {
        console.log(
          `Preparing to open voice stream channel with ${remoteUserName} (${remoteUserId})...`
        );
        await navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
          stream.getTracks().forEach((track) => {
            console.log(
              "Adding track:",
              track,
              `to peer ${remoteUserName} (${remoteUserId})...`
            );
            voiceConnection.addTrack(track, stream);
          });
          console.log(
            `Opened voice stream channel with ${remoteUserName} (${remoteUserId}).`
          );
        }).catch((err) => {
          console.error(
            `Error adding audio stream for peer ${remoteUserName} (${remoteUserId}):`,
            err
          );
        });
      }
      closeVoiceStream(remoteUserId) {
        const audioElement = document.getElementById(`audio_${remoteUserId}`);
        if (audioElement) {
          console.log(`Removing peer ${remoteUserId} audio stream...`);
          document.body.removeChild(audioElement);
        }
        this.voiceConnections.delete(remoteUserId);
        delete this.iceCandidates[remoteUserId];
      }
      createChannel(remoteUserId, label, ordered) {
        const peerConnection = this.peerConnections.get(remoteUserId);
        const dataChannel = peerConnection.createDataChannel(label, {
          negotiated: false,
          ordered,
          protocol: "clomega"
        });
        this.handleDataChannel(dataChannel, remoteUserId, peerConnection.user);
        return dataChannel;
      }
      doesPeerExist(remoteUserId) {
        if (!this.peerConnections.get(remoteUserId))
          return false;
        return this.peerConnections.get(remoteUserId).connectionState == "connected";
      }
      doesPeerChannelExist(remoteUserId, channel) {
        if (!this.doesPeerExist(remoteUserId))
          return false;
        return this.dataChannels.get(remoteUserId).has(channel);
      }
      createDefaultChannel(peerConnection, remoteUserId, remoteUserName) {
        const dataChannel = peerConnection.createDataChannel("default", {
          negotiated: true,
          id: 0,
          ordered: true,
          protocol: "clomega"
        });
        this.handleDataChannel(dataChannel, remoteUserId, remoteUserName);
        return dataChannel;
      }
      disconnectDataPeer(remoteUserId) {
        const peerConnection = this.peerConnections.get(remoteUserId);
        if (peerConnection) {
          const remoteUserName = peerConnection.user;
          peerConnection.close();
          this.peerConnections.delete(remoteUserId);
          delete this.iceCandidates[remoteUserId];
          if (this.dataChannels.has(remoteUserId)) {
            const channels = this.dataChannels.get(remoteUserId);
            for (const channel of channels.values()) {
              channel.close();
            }
            this.dataChannels.delete(remoteUserId);
          }
          console.log(`Disconnected peer ${remoteUserName} (${remoteUserId}).`);
        }
      }
      onIceCandidate(remoteUserId, callback) {
        this.messageHandlers.onIceCandidate[remoteUserId] = callback;
      }
      onIceGatheringDone(remoteUserId, callback) {
        this.messageHandlers.onIceGatheringDone[remoteUserId] = callback;
      }
      onChannelOpen(remoteUserId, callback) {
        this.messageHandlers.onChannelOpen[remoteUserId] = callback;
      }
      onChannelClose(callback) {
        this.messageHandlers.onChannelClose = callback;
      }
      onChannelMessage(remoteUserId, callback) {
        this.messageHandlers.onChannelMessage[remoteUserId] = callback;
      }
      broadcastData(channelLabel, opcode, payload, wait) {
        if (wait) {
          const promises = [];
          for (const remotePeerId of Object.values(this.getPeers())) {
            promises.push(
              OmegaRTCInstance.sendData(
                remotePeerId,
                channelLabel,
                opcode,
                payload,
                true
              )
            );
          }
          return Promise.all(promises);
        } else {
          for (const remotePeerId of Object.values(this.getPeers())) {
            OmegaRTCInstance.sendData(
              remotePeerId,
              channelLabel,
              opcode,
              payload,
              false
            );
          }
        }
      }
      sendData(remoteUserId, channelLabel, opcode, payload, wait) {
        const peer = this.dataChannels.get(remoteUserId);
        if (!peer) {
          return;
        }
        const channel = peer.get(channelLabel);
        if (!channel) {
          return;
        }
        if (wait)
          channel.bufferedAmountLowThreshold = 0;
        channel.send(
          JSON.stringify({
            opcode,
            payload
          })
        );
        if (wait)
          return new Promise((resolve) => {
            channel.onbufferedamountlow = () => {
              resolve();
            };
          });
      }
      getChannelData(remoteUserId, channelLabel, channelDataType) {
        const peer = this.dataChannels.get(remoteUserId);
        if (!peer)
          return;
        const channel = peer.get(channelLabel);
        if (!channel)
          return;
        return channel.dataStorage.get(channelDataType);
      }
      removeIceCandidate(remoteUserId, candidate) {
        if (this.iceCandidates[remoteUserId].includes(candidate)) {
          this.iceCandidates[remoteUserId].splice(
            this.iceCandidates[remoteUserId].indexOf(candidate),
            1
          );
        }
      }
    }
    class OmegaSignaling {
      // Define types
      enableKeepalive;
      keepalive;
      messageHandlers;
      lobbyList;
      lobbyInfo;
      state;
      socket;
      runtime;
      constructor(runtime) {
        this.enableKeepalive = true;
        this.keepalive = null;
        this.runtime = runtime;
        this.messageHandlers = {
          onInitSuccess: null,
          onConnect: null,
          onClose: {},
          offer: null,
          answer: null,
          keepalive: null,
          onHostModeConfig: null,
          onPeerModeConfig: null,
          onModeConfigFailure: null,
          onNewHost: null,
          onAnticipate: null,
          onNewPeer: null,
          onPeerGone: {},
          onHostGone: {},
          onIceCandidateReceived: {},
          onOffer: null,
          onAnswer: null,
          listeners: {},
          onDiscover: null,
          onLobbyList: null,
          onLobbyInfo: null
        };
        this.lobbyList = [];
        this.lobbyInfo = {};
        this.state = {
          user: "",
          // username
          id: "",
          // ULID
          game: "",
          // game name
          developer: "",
          // developer name
          mode: 0,
          // 0 - configuring, 1 - host, 2 - peer
          authenticated: false
        };
      }
      Connect(url) {
        this.socket = new WebSocket(url);
        this.socket.onopen = () => {
          if (this.enableKeepalive) {
            this.sendMessage({ opcode: "KEEPALIVE" });
          }
          if (this.messageHandlers.onConnect)
            this.messageHandlers.onConnect();
        };
        this.socket.onclose = (event) => {
          this.state.id = "";
          this.state.user = "";
          this.state.developer = "";
          this.state.game = "";
          this.state.mode = 0;
          this.state.authenticated = false;
          this.socket = null;
          this.lobbyList = [];
          this.lobbyInfo = {};
          clearTimeout(this.keepalive);
          Object.keys(this.messageHandlers.onClose).forEach((tag) => {
            this.messageHandlers.onClose[tag](event);
          });
        };
        this.socket.onerror = (error) => {
          console.error("Signaling connection error:", error);
        };
        this.socket.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            this.handleMessage(message);
          } catch (error) {
            console.error("Error handling message:", error);
          }
        };
      }
      handleMessage(message) {
        const { opcode, payload, listener } = message;
        switch (opcode) {
          case "INIT_OK":
            console.log("Signaling login successful.");
            this.state.user = payload.user;
            this.state.id = payload.id;
            this.state.game = payload.game;
            this.state.developer = payload.developer;
            this.state.authenticated = true;
            if (this.messageHandlers.onInitSuccess)
              this.messageHandlers.onInitSuccess();
            break;
          case "ACK_HOST":
            console.log("Acknowledgement received: Operating in host mode.");
            if (this.messageHandlers.onHostModeConfig)
              this.messageHandlers.onHostModeConfig();
            this.state.mode = 1;
            break;
          case "ACK_PEER":
            console.log("Acknowledgement received: Operating in peer mode.");
            if (this.messageHandlers.onPeerModeConfig)
              this.messageHandlers.onPeerModeConfig();
            this.state.mode = 2;
            break;
          case "VIOLATION":
            console.error("Protocol violation: " + payload);
            break;
          case "WARNING":
            console.warn("Protocol warning: " + payload);
            break;
          case "CONFIG_REQUIRED":
            console.warn("Configuration required: " + payload);
            break;
          case "RELAY_OK":
            break;
          case "KEEPALIVE":
            this.keepalive = setTimeout(() => {
              this.sendMessage({ opcode: "KEEPALIVE" });
            }, 5e3);
            break;
          case "LOBBY_LIST":
            this.lobbyList = payload;
            if (this.messageHandlers.onLobbyList)
              this.messageHandlers.onLobbyList();
            break;
          case "LOBBY_INFO":
            this.lobbyInfo = payload;
            if (this.messageHandlers.onLobbyInfo)
              this.messageHandlers.onLobbyInfo();
            break;
          case "LOBBY_FULL":
            console.warn("Lobby is full.");
            if (this.messageHandlers.onModeConfigFailure)
              this.messageHandlers.onModeConfigFailure(opcode);
            break;
          case "LOBBY_EXISTS":
            console.warn("Lobby already exists.");
            if (this.messageHandlers.onModeConfigFailure)
              this.messageHandlers.onModeConfigFailure(opcode);
            break;
          case "LOBBY_NOTFOUND":
            console.warn("Lobby does not exist.");
            if (this.messageHandlers.onModeConfigFailure)
              this.messageHandlers.onModeConfigFailure(opcode);
            if (this.messageHandlers.onLobbyInfo)
              this.messageHandlers.onLobbyInfo();
            break;
          case "LOBBY_LOCKED":
            console.warn("Lobby is not accepting connections at this time.");
            if (this.messageHandlers.onModeConfigFailure)
              this.messageHandlers.onModeConfigFailure(opcode);
            break;
          case "PASSWORD_FAIL":
            console.warn(
              "Lobby is password protected and incorrect password was provided."
            );
            if (this.messageHandlers.onModeConfigFailure)
              this.messageHandlers.onModeConfigFailure(opcode);
            break;
          case "LOBBY_CLOSE":
            console.log(`Lobby ${payload} closed.`);
            if (this.state.mode == 1 || this.state.mode == 2) {
              console.log("Disconnecting from lobby..");
              this.Disconnect();
            }
            break;
          case "HOST_GONE":
            console.log("The host has left.");
            if (this.messageHandlers.onHostGone[payload])
              this.messageHandlers.onHostGone[payload]();
            break;
          case "PEER_GONE":
            console.log(`Peer ${payload} has left.`);
            if (this.messageHandlers.onPeerGone[payload])
              this.messageHandlers.onPeerGone[payload]();
            break;
          case "SESSION_EXISTS":
            console.warn("Protocol warning: Session already exists.");
            break;
          case "TOKEN_INVALID":
            console.warn("Protocol warning: Invalid token.");
            break;
          case "TOKEN_EXPIRED":
            console.warn("Protocol warning: Token expired.");
            break;
          case "TOKEN_ORIGIN_MISMATCH":
            console.warn(
              "Protocol warning: Attempted to use a token generated on a different domain."
            );
            break;
          case "DISCOVER":
            if (this.messageHandlers.onDiscover)
              this.messageHandlers.onDiscover(message);
            break;
          case "ANTICIPATE":
            if (this.messageHandlers.onAnticipate)
              this.messageHandlers.onAnticipate(message);
            break;
          case "NEW_PEER":
            if (this.messageHandlers.onNewPeer)
              this.messageHandlers.onNewPeer(message);
            break;
          case "NEW_HOST":
            if (this.messageHandlers.onNewHost)
              this.messageHandlers.onNewHost(message);
            break;
          case "MAKE_OFFER":
            if (this.messageHandlers.onOffer)
              this.messageHandlers.onOffer(message);
            break;
          case "MAKE_ANSWER":
            if (this.messageHandlers.onAnswer)
              this.messageHandlers.onAnswer(message);
            break;
          case "ICE":
            if (this.messageHandlers.onIceCandidateReceived)
              this.messageHandlers.onIceCandidateReceived(message);
            break;
        }
        if (this.messageHandlers[listener])
          this.messageHandlers[listener](message);
      }
      hostMode(lobby_id, allow_host_reclaim, allow_peers_to_claim_host, max_peers, password, pubkey, listener) {
        this.sendMessage({
          opcode: "CONFIG_HOST",
          payload: {
            lobby_id,
            allow_host_reclaim,
            allow_peers_to_claim_host,
            max_peers,
            password,
            pubkey
          },
          listener
        });
      }
      peerMode(lobby_id, password, pubkey, listener) {
        this.sendMessage({
          opcode: "CONFIG_PEER",
          payload: {
            lobby_id,
            password,
            pubkey
          },
          listener
        });
      }
      authenticateWithToken(token, listener) {
        this.sendMessage({ opcode: "INIT", payload: token, listener });
      }
      sendOffer(recipient, offer, listener) {
        this.sendMessage({
          opcode: "MAKE_OFFER",
          payload: offer,
          recipient,
          listener
        });
      }
      sendAnswer(recipient, answer, listener) {
        this.sendMessage({
          opcode: "MAKE_ANSWER",
          payload: answer,
          recipient,
          listener
        });
      }
      sendIceCandidate(recipient, answer, listener) {
        this.sendMessage({ opcode: "ICE", payload: answer, recipient, listener });
      }
      sendGetLobbyList(listener) {
        this.sendMessage({ opcode: "LOBBY_LIST", listener });
      }
      sendGetLobbyInfo(payload, listener) {
        this.sendMessage({ opcode: "LOBBY_INFO", payload, listener });
      }
      Disconnect() {
        this.socket.close();
      }
      sendMessage(message) {
        if (this.socket.readyState === WebSocket.OPEN) {
          this.socket.send(JSON.stringify(message));
        } else {
          console.error(
            "WebSocket connection not open. Cannot send message:",
            message
          );
        }
      }
      onAnswer(callback) {
        this.messageHandlers.onAnswer = callback;
      }
      onPeerGone(remoteUserId, callback) {
        this.messageHandlers.onPeerGone[remoteUserId] = callback;
      }
      onHostGone(remoteUserId, callback) {
        this.messageHandlers.onHostGone[remoteUserId] = callback;
      }
      onDiscover(callback) {
        this.messageHandlers.onDiscover = callback;
      }
      onAnticipate(callback) {
        this.messageHandlers.onAnticipate = callback;
      }
      onNewHost(callback) {
        this.messageHandlers.onNewHost = callback;
      }
      onNewPeer(callback) {
        this.messageHandlers.onNewPeer = callback;
      }
      onHostModeConfig(callback) {
        this.messageHandlers.onHostModeConfig = callback;
      }
      onPeerModeConfig(callback) {
        this.messageHandlers.onPeerModeConfig = callback;
      }
      onModeConfigFailure(callback) {
        this.messageHandlers.onModeConfigFailure = callback;
      }
      onIceCandidateReceived(callback) {
        this.messageHandlers.onIceCandidateReceived = callback;
      }
      onListener(name, callback) {
        this.messageHandlers.listeners[name] = callback;
      }
      onConnect(callback) {
        this.messageHandlers.onConnect = callback;
      }
      onInitSuccess(callback) {
        this.messageHandlers.onInitSuccess = callback;
      }
      onOffer(callback) {
        this.messageHandlers.onOffer = callback;
      }
      onClose(tag, callback) {
        this.messageHandlers.onClose[tag] = callback;
      }
      onLobbyInfo(callback) {
        this.messageHandlers.onLobbyInfo = callback;
      }
      onLobbyList(callback) {
        this.messageHandlers.onLobbyList = callback;
      }
    }
    class NetworkedScratchData {
      WebRTC;
      blessVarTracker;
      blessListTracker;
      networkUpdateTracker;
      constructor(rtc) {
        this.WebRTC = rtc;
        this.blessVarTracker = [];
        this.blessListTracker = [];
        this.networkUpdateTracker = {};
      }
      // Create a function to convert a variable into a proxy
      createVariableProxy(myVar) {
        const eventHandlers = [];
        const runEvents = () => {
          eventHandlers.forEach((handler) => handler());
        };
        const proxy = new Proxy(myVar, {
          set(target, property, value) {
            if (property === "value")
              runEvents();
            target[property] = value;
            return true;
          }
        });
        proxy.on = (handler) => {
          eventHandlers.push(handler);
        };
        proxy.off = (handler) => {
          const index = eventHandlers.indexOf(handler);
          if (index !== -1) {
            eventHandlers.splice(index, 1);
          }
        };
        return proxy;
      }
      // Create a function to convert an array into a proxy
      createArrayProxy(myList) {
        const array = myList.value;
        const eventHandlers = [];
        const runEvents = (type, data) => {
          eventHandlers.forEach((handler) => handler(type, data));
        };
        const proxy = new Proxy(array, {
          set(target, property, value) {
            if (property === "length") {
              runEvents("length", value);
            } else if (!isNaN(Number(property))) {
              if (Number(property) < target.length) {
                runEvents("replace", { property, value });
              } else {
                runEvents("set", { property, value });
              }
            }
            target[property] = value;
            return true;
          }
        });
        proxy.on = (handler) => {
          eventHandlers.push(handler);
        };
        proxy.off = (handler) => {
          const index = eventHandlers.indexOf(handler);
          if (index !== -1) {
            eventHandlers.splice(index, 1);
          }
        };
        return proxy;
      }
      update(runtime) {
        this.blessListTracker.forEach((myListId) => {
          if (!this.networkUpdateTracker.hasOwnProperty(myListId)) {
            this.networkUpdateTracker[myListId] = {};
            this.networkUpdateTracker[myListId].current = false;
            this.networkUpdateTracker[myListId].last = true;
          }
          let exists = false;
          const validTargets = [];
          runtime.targets.forEach((target) => {
            if (target.lookupVariableById(myListId) != void 0 && !exists) {
              validTargets.push(target);
              exists = true;
            }
          });
          if (!exists) {
            delete this.networkUpdateTracker[myListId];
            this.blessListTracker.splice(
              this.blessListTracker.indexOf(myListId),
              1
            );
            backupSettings(runtime);
          }
          validTargets.forEach((target) => {
            if (!target.variables[myListId].value.hasOwnProperty("bless")) {
              const myList = target.variables[myListId];
              this.makeNetworkedList(myList);
              this.onListChange(myList, "reset", myList.value);
            }
          });
        });
        this.blessVarTracker.forEach((myVarId) => {
          if (!this.networkUpdateTracker.hasOwnProperty(myVarId)) {
            this.networkUpdateTracker[myVarId] = {};
            this.networkUpdateTracker[myVarId].current = false;
            this.networkUpdateTracker[myVarId].last = true;
          }
          let exists = false;
          const validTargets = [];
          runtime.targets.forEach((target) => {
            if (target.lookupVariableById(myVarId) != void 0 && !exists) {
              validTargets.push(target);
              exists = true;
            }
          });
          if (!exists) {
            delete this.networkUpdateTracker[myVarId];
            this.blessVarTracker.splice(this.blessVarTracker.indexOf(myVarId), 1);
            backupSettings(runtime);
          }
          validTargets.forEach((target) => {
            if (!target.variables[myVarId].hasOwnProperty("bless")) {
              const myVar = target.variables[myVarId];
              this.makeNetworkedVariable(myVar);
              this.onVariableChange(myVar);
            }
          });
        });
      }
      onListChange(myList, eventType, eventData) {
        myList._monitorUpToDate = false;
        if (this.networkUpdateTracker[myList.id].current) {
          this.networkUpdateTracker[myList.id].current = false;
          this.networkUpdateTracker[myList.id].last = true;
        } else {
          switch (eventType) {
            case "reset":
              if (this.networkUpdateTracker[myList.id].last) {
                this.networkUpdateTracker[myList.id].last = false;
                return;
              }
              this.WebRTC.broadcastData(
                "default",
                "G_LIST",
                {
                  id: myList.id,
                  method: "reset",
                  value: eventData
                },
                false
              );
              break;
            case "set":
              if (this.networkUpdateTracker[myList.id].last) {
                this.networkUpdateTracker[myList.id].last = false;
                return;
              }
              this.WebRTC.broadcastData(
                "default",
                "G_LIST",
                {
                  id: myList.id,
                  method: "set",
                  index: eventData.property,
                  value: eventData.value
                },
                false
              );
              break;
            case "replace":
              if (this.networkUpdateTracker[myList.id].last) {
                this.networkUpdateTracker[myList.id].last = false;
                return;
              }
              this.WebRTC.broadcastData(
                "default",
                "G_LIST",
                {
                  id: myList.id,
                  method: "replace",
                  index: eventData.property,
                  value: eventData.value
                },
                false
              );
              break;
            case "length":
              if (this.networkUpdateTracker[myList.id].last) {
                this.networkUpdateTracker[myList.id].last = false;
                return;
              }
              for (const remotePeerId of Object.values(this.WebRTC.getPeers())) {
                this.WebRTC.sendData(
                  remotePeerId,
                  "default",
                  "G_LIST",
                  {
                    id: myList.id,
                    method: "length",
                    value: eventData
                  },
                  false
                );
              }
              break;
          }
        }
      }
      onVariableChange(myVar) {
        if (this.networkUpdateTracker[myVar.id].current) {
          this.networkUpdateTracker[myVar.id].current = false;
          this.networkUpdateTracker[myVar.id].last = true;
        } else {
          if (this.networkUpdateTracker[myVar.id].last) {
            this.networkUpdateTracker[myVar.id].last = false;
            return;
          }
          for (const remotePeerId of Object.values(this.WebRTC.getPeers())) {
            this.WebRTC.sendData(
              remotePeerId,
              "default",
              "G_VAR",
              {
                id: myVar.id,
                value: myVar.value
              },
              false
            );
          }
        }
      }
      makeNetworkedVariable(myVar) {
        const varProxy = this.createVariableProxy(myVar);
        myVar = varProxy;
        Object.defineProperty(myVar, "bless", {
          enumerable: false,
          configurable: true,
          writable: true,
          value: true
        });
        if (!this.networkUpdateTracker.hasOwnProperty(myVar.id)) {
          this.networkUpdateTracker[myVar.id] = {};
          this.networkUpdateTracker[myVar.id].current = false;
          this.networkUpdateTracker[myVar.id].last = false;
        }
        myVar.on(() => {
          this.onVariableChange(myVar);
        });
        if (!this.blessVarTracker.includes(myVar.id)) {
          this.blessVarTracker.push(myVar.id);
        }
      }
      makeNetworkedList(myList) {
        const newProxy = this.createArrayProxy(myList);
        myList.value = newProxy;
        Object.defineProperty(myList.value, "bless", {
          enumerable: false,
          configurable: true,
          writable: true,
          value: true
        });
        if (!this.networkUpdateTracker.hasOwnProperty(myList.id)) {
          this.networkUpdateTracker[myList.id] = {};
          this.networkUpdateTracker[myList.id].current = false;
          this.networkUpdateTracker[myList.id].last = false;
        }
        myList.value.on((eventType, eventData) => {
          this.onListChange(myList, eventType, eventData);
        });
        if (!this.blessListTracker.includes(myList.id)) {
          this.blessListTracker.push(myList.id);
        }
      }
    }
    const OmegaSignalingInstance = new OmegaSignaling(Scratch.runtime);
    const OmegaEncryptionInstance = new OmegaEncryption();
    const OmegaRTCInstance = new OmegaRTC(
      OmegaEncryptionInstance,
      OmegaSignalingInstance
    );
    const NetworkedScratchDataInstance = new NetworkedScratchData(
      OmegaRTCInstance
    );
    OmegaEncryptionInstance.generateKeyPair();
    function backupSettings(runtime) {
      if (!runtime) {
        console.error("No runtime found!");
        return;
      }
      const stage = runtime.targets[0];
      let configId = null;
      let configFound = false;
      for (const id of Object.keys(stage.comments)) {
        if (stage.comments[id].text.includes(configEnd)) {
          configId = id;
          configFound = true;
          break;
        }
      }
      const newConfig = `${infoBlurb}${JSON.stringify({
        lists: NetworkedScratchDataInstance.blessListTracker,
        // Array
        variables: NetworkedScratchDataInstance.blessVarTracker,
        // Array
        keepalive: OmegaSignalingInstance.enableKeepalive ? 1 : 0
        // Boolean (as integer)
      })} ${configEnd}`;
      if (!configFound) {
        stage.createComment(
          uid(),
          // Comment ID
          null,
          // Block ID that the comment is attached to (set to null by default)
          newConfig,
          // Comment text
          0,
          // X position of the comment
          0,
          // Y position of the comment
          620,
          // Width of the comment
          125,
          // Height of the comment
          false
          // Is the comment minimized?
        );
      } else {
        stage.comments[configId].text = newConfig;
      }
    }
    function restoreSettings(runtime) {
      if (!runtime) {
        console.error("No runtime found!");
        return;
      }
      const stage = runtime.targets[0];
      let configId = null;
      for (const id of Object.keys(stage.comments)) {
        if (stage.comments[id].text.includes(configEnd)) {
          configId = id;
          break;
        }
      }
      if (!configId)
        return;
      const config = JSON.parse(
        stage.comments[configId].text.split(infoBlurb)[1].split(configEnd)[0].trim()
      );
      OmegaSignalingInstance.enableKeepalive = config.keepalive ? true : false;
      NetworkedScratchDataInstance.blessVarTracker = config.variables;
      NetworkedScratchDataInstance.blessListTracker = config.lists;
    }
    class CloudLink5 {
      // Declare types
      vm;
      runtime;
      hasMicPerms;
      globalDataStorage;
      globalVariableStorage;
      globalListStorage;
      newestPeerConnected;
      blockIconURI;
      menuIconURI;
      constructor(vm) {
        this.vm = vm;
        this.runtime = vm.runtime;
        this.hasMicPerms = false;
        this.globalDataStorage = /* @__PURE__ */ new Map();
        this.globalVariableStorage = /* @__PURE__ */ new Map();
        this.globalListStorage = /* @__PURE__ */ new Map();
        this.newestPeerConnected = "";
        this.blockIconURI = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTc3IiBoZWlnaHQ9IjEyMyIgdmlld0JveD0iMCAwIDE3NyAxMjMiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8xXzE5KSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTM0LjMyIDM4LjUxMjlDMTU3LjU2MSAzOC41MTI5IDE3Ni4zOTkgNTcuMzUyMyAxNzYuMzk5IDgwLjU5MThDMTc2LjM5OSAxMDMuODMxIDE1Ny41NjEgMTIyLjY3MSAxMzQuMzIgMTIyLjY3MUg0Mi4wNzg5QzE4LjgzOCAxMjIuNjcxIDAgMTAzLjgzMSAwIDgwLjU5MThDMCA1Ny4zNTIzIDE4LjgzOCAzOC41MTI5IDQyLjA3ODkgMzguNTEyOUg0Ni4yNjc4QzQ4LjA3OTMgMTYuOTQyMyA2Ni4xNjEzIDAgODguMTk5MyAwQzExMC4yMzcgMCAxMjguMzE5IDE2Ljk0MjMgMTMwLjEzMSAzOC41MTI5SDEzNC4zMloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik04Ny40MTk4IDEwNS4zMzNDODIuOTM3OCAxMDUuMzMzIDc4Ljc4NzggMTA0LjQ3NSA3NC45Njk4IDEwMi43NkM3MS4xNTE4IDEwMC45ODkgNjcuOTQyNSA5OC42NjUgNjUuMzQxOCA5NS43ODc3TDcxLjg5ODggODcuNTcwNkM3NC4yNzgyIDg5LjgzOTMgNzYuNzQwNSA5MS41ODIzIDc5LjI4NTggOTIuNzk5NkM4MS44ODY1IDk0LjAxNyA4NC40ODcyIDk0LjYyNTYgODcuMDg3OCA5NC42MjU2Qzg5LjUyMjUgOTQuNjI1NiA5MS42ODA1IDk0LjIzODMgOTMuNTYxOCA5My40NjM2Qzk1LjQ0MzIgOTIuNjMzNiA5Ni44ODE4IDkxLjQ5OTMgOTcuODc3OCA5MC4wNjA2Qzk4LjkyOTIgODguNTY2NiA5OS40NTQ4IDg2LjgyMzYgOTkuNDU0OCA4NC44MzE2Qzk5LjQ1NDggODIuOTUwMyA5OC45MjkyIDgxLjI5MDMgOTcuODc3OCA3OS44NTE2Qzk2LjgyNjUgNzguNDEzIDk1LjM4NzggNzcuMjc4NiA5My41NjE4IDc2LjQ0ODZDOTEuNzM1OCA3NS42MTg2IDg5LjY4ODUgNzUuMjAzNiA4Ny40MTk4IDc1LjIwMzZDODUuMzE3MiA3NS4yMDM2IDgzLjQzNTggNzUuMzk3MyA4MS43NzU4IDc1Ljc4NDZDODAuMTE1OCA3Ni4xNzIgNzguNjIxOCA3Ni42NDIzIDc3LjI5MzggNzcuMTk1NkM3NS45NjU4IDc3LjY5MzYgNzQuNzc2MiA3OC4yNDcgNzMuNzI0OCA3OC44NTU2TDY4LjA4MDggNzEuNjM0Nkw3MS42NDk4IDQ2LjMxOTZIMTA2LjUxVjU3LjAyNjZINzcuOTU3OEw4MC45NDU4IDUzLjM3NDZMNzguMjA2OCA3MS44MDA2TDc0LjMwNTggNjkuODkxNkM3NS4yNDY1IDY5LjExNyA3Ni41NDY4IDY4LjM5NzYgNzguMjA2OCA2Ny43MzM2Qzc5Ljg2NjggNjcuMDY5NiA4MS43MjA1IDY2LjUxNjMgODMuNzY3OCA2Ni4wNzM2Qzg1LjgxNTIgNjUuNjMxIDg3LjgzNDggNjUuNDA5NiA4OS44MjY4IDY1LjQwOTZDOTMuNzAwMiA2NS40MDk2IDk3LjI0MTUgNjYuMjM5NiAxMDAuNDUxIDY3Ljg5OTZDMTAzLjY2IDY5LjUwNDMgMTA2LjIzMyA3MS43NzMgMTA4LjE3IDc0LjcwNTZDMTEwLjEwNiA3Ny42MzgzIDExMS4wNzUgODEuMDY5IDExMS4wNzUgODQuOTk3NkMxMTEuMDc1IDg4LjgxNTYgMTEwLjAyMyA5Mi4yNzQgMTA3LjkyMSA5NS4zNzI3QzEwNS44MTggOTguNDE2IDEwMi45NjggMTAwLjg1MSA5OS4zNzE4IDEwMi42NzdDOTUuODMwNSAxMDQuNDQ3IDkxLjg0NjUgMTA1LjMzMyA4Ny40MTk4IDEwNS4zMzNaIiBmaWxsPSIjMEZCRDhDIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMV8xOSI+CjxyZWN0IHdpZHRoPSIxNzYuMzk5IiBoZWlnaHQ9IjEyMi42NzEiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==";
        this.menuIconURI = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjI2IiBoZWlnaHQ9IjIyNiIgdmlld0JveD0iMCAwIDIyNiAyMjYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8xXzEzKSI+CjxwYXRoIGQ9Ik0wIDExMi42NzdDMCA1MC40NDc0IDUwLjQ0NzQgMCAxMTIuNjc3IDBDMTc0LjkwNyAwIDIyNS4zNTUgNTAuNDQ3NCAyMjUuMzU1IDExMi42NzdDMjI1LjM1NSAxNzQuOTA3IDE3NC45MDcgMjI1LjM1NSAxMTIuNjc3IDIyNS4zNTVDNTAuNDQ3NCAyMjUuMzU1IDAgMTc0LjkwNyAwIDExMi42NzdaIiBmaWxsPSIjMEZCRDhDIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTU4LjUzNSA4My43NjEyQzE4MS43NzYgODMuNzYxMiAyMDAuNjE0IDEwMi42MDEgMjAwLjYxNCAxMjUuODRDMjAwLjYxNCAxNDkuMDggMTgxLjc3NiAxNjcuOTE5IDE1OC41MzUgMTY3LjkxOUg2Ni4yOTQxQzQzLjA1MzIgMTY3LjkxOSAyNC4yMTUyIDE0OS4wOCAyNC4yMTUyIDEyNS44NEMyNC4yMTUyIDEwMi42MDEgNDMuMDUzMiA4My43NjEyIDY2LjI5NDEgODMuNzYxMkg3MC40ODNDNzIuMjk0NSA2Mi4xOTA3IDkwLjM3NjUgNDUuMjQ4NCAxMTIuNDE0IDQ1LjI0ODRDMTM0LjQ1MiA0NS4yNDg0IDE1Mi41MzQgNjIuMTkwNyAxNTQuMzQ2IDgzLjc2MTJIMTU4LjUzNVoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0xMTEuNjM1IDE1MC41ODFDMTA3LjE1MyAxNTAuNTgxIDEwMy4wMDMgMTQ5LjcyMyA5OS4xODUgMTQ4LjAwOEM5NS4zNjcgMTQ2LjIzNyA5Mi4xNTc3IDE0My45MTMgODkuNTU3IDE0MS4wMzZMOTYuMTE0IDEzMi44MTlDOTguNDkzMyAxMzUuMDg4IDEwMC45NTYgMTM2LjgzMSAxMDMuNTAxIDEzOC4wNDhDMTA2LjEwMiAxMzkuMjY1IDEwOC43MDIgMTM5Ljg3NCAxMTEuMzAzIDEzOS44NzRDMTEzLjczOCAxMzkuODc0IDExNS44OTYgMTM5LjQ4NyAxMTcuNzc3IDEzOC43MTJDMTE5LjY1OCAxMzcuODgyIDEyMS4wOTcgMTM2Ljc0OCAxMjIuMDkzIDEzNS4zMDlDMTIzLjE0NCAxMzMuODE1IDEyMy42NyAxMzIuMDcyIDEyMy42NyAxMzAuMDhDMTIzLjY3IDEyOC4xOTkgMTIzLjE0NCAxMjYuNTM5IDEyMi4wOTMgMTI1LjFDMTIxLjA0MiAxMjMuNjYxIDExOS42MDMgMTIyLjUyNyAxMTcuNzc3IDEyMS42OTdDMTE1Ljk1MSAxMjAuODY3IDExMy45MDQgMTIwLjQ1MiAxMTEuNjM1IDEyMC40NTJDMTA5LjUzMiAxMjAuNDUyIDEwNy42NTEgMTIwLjY0NiAxMDUuOTkxIDEyMS4wMzNDMTA0LjMzMSAxMjEuNDIgMTAyLjgzNyAxMjEuODkxIDEwMS41MDkgMTIyLjQ0NEMxMDAuMTgxIDEyMi45NDIgOTguOTkxMyAxMjMuNDk1IDk3Ljk0IDEyNC4xMDRMOTIuMjk2IDExNi44ODNMOTUuODY1IDkxLjU2OEgxMzAuNzI1VjEwMi4yNzVIMTAyLjE3M0wxMDUuMTYxIDk4LjYyM0wxMDIuNDIyIDExNy4wNDlMOTguNTIxIDExNS4xNEM5OS40NjE3IDExNC4zNjUgMTAwLjc2MiAxMTMuNjQ2IDEwMi40MjIgMTEyLjk4MkMxMDQuMDgyIDExMi4zMTggMTA1LjkzNiAxMTEuNzY1IDEwNy45ODMgMTExLjMyMkMxMTAuMDMgMTEwLjg3OSAxMTIuMDUgMTEwLjY1OCAxMTQuMDQyIDExMC42NThDMTE3LjkxNSAxMTAuNjU4IDEyMS40NTcgMTExLjQ4OCAxMjQuNjY2IDExMy4xNDhDMTI3Ljg3NSAxMTQuNzUzIDEzMC40NDggMTE3LjAyMSAxMzIuMzg1IDExOS45NTRDMTM0LjMyMiAxMjIuODg3IDEzNS4yOSAxMjYuMzE3IDEzNS4yOSAxMzAuMjQ2QzEzNS4yOSAxMzQuMDY0IDEzNC4yMzkgMTM3LjUyMiAxMzIuMTM2IDE0MC42MjFDMTMwLjAzMyAxNDMuNjY0IDEyNy4xODQgMTQ2LjA5OSAxMjMuNTg3IDE0Ny45MjVDMTIwLjA0NiAxNDkuNjk2IDExNi4wNjIgMTUwLjU4MSAxMTEuNjM1IDE1MC41ODFaIiBmaWxsPSIjMEZCRDhDIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMV8xMyI+CjxyZWN0IHdpZHRoPSIyMjUuMzU1IiBoZWlnaHQ9IjIyNS4zNTUiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==";
      }
      // Define blocks used in the extension
      // @ts-expect-error Scratch.BlockType.EVENT has a weird catch-22 issue with isEdgeActivated.
      getInfo() {
        return {
          id: "cl5",
          name: "CL5",
          docsURI: "https://github.com/cloudlink-omega/cl5/wiki/Extension",
          blockIconURI: this.blockIconURI,
          menuIconURI: this.menuIconURI,
          color1: "#0FBD8C",
          color2: "#80C6B2",
          color3: "#0A7255",
          blocks: [
            {
              opcode: "on_signalling_connect",
              blockType: Scratch2.BlockType.HAT,
              text: "When I am connected to signaling server"
            },
            {
              opcode: "on_signalling_disconnect",
              blockType: Scratch2.BlockType.HAT,
              text: "When I am disconnected from signaling server"
            },
            {
              opcode: "initialize",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Connect to signaling server [SERVER]",
              arguments: {
                SERVER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: ""
                }
              }
            },
            {
              opcode: "leave",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Disconnect from signaling server"
            },
            {
              opcode: "is_signalling_connected",
              blockType: Scratch2.BlockType.BOOLEAN,
              text: "Connected to signaling server?"
            },
            {
              opcode: "authenticate",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Authenticate with token [TOKEN]",
              arguments: {
                TOKEN: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: ""
                }
              }
            },
            {
              opcode: "is_signaling_auth_success",
              blockType: Scratch2.BlockType.BOOLEAN,
              text: "Authenticated successfully?"
            },
            {
              opcode: "my_ID",
              blockType: Scratch2.BlockType.REPORTER,
              text: "My Peer ID"
            },
            {
              opcode: "my_Username",
              blockType: Scratch2.BlockType.REPORTER,
              text: "My Username"
            },
            {
              opcode: "get_peers",
              blockType: Scratch2.BlockType.REPORTER,
              text: "Connected peers"
            },
            {
              opcode: "get_peer_channels",
              blockType: Scratch2.BlockType.REPORTER,
              text: "Peer [PEER] channels",
              arguments: {
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                }
              }
            },
            {
              opcode: "is_peer_connected",
              blockType: Scratch2.BlockType.BOOLEAN,
              text: "Connected to peer [PEER]?",
              arguments: {
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                }
              }
            },
            {
              opcode: "disconnect_peer",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Close connection with peer [PEER]",
              arguments: {
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                }
              }
            },
            {
              opcode: "new_dchan",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Open a new data channel named [CHANNEL] with peer [PEER] and prefer [ORDERED]",
              arguments: {
                CHANNEL: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "foobar"
                },
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                },
                ORDERED: {
                  type: Scratch2.ArgumentType.NUMBER,
                  menu: "channelConfig",
                  defaultValue: 1
                }
              }
            },
            {
              opcode: "close_dchan",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Close data channel named [CHANNEL] with peer [PEER]",
              arguments: {
                CHANNEL: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "foobar"
                },
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                }
              }
            },
            {
              opcode: "lobby_list",
              blockType: Scratch2.BlockType.REPORTER,
              text: "All public lobbies"
            },
            {
              opcode: "query_lobbies",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Refresh public lobbies list"
            },
            {
              opcode: "lobby_info",
              blockType: Scratch2.BlockType.REPORTER,
              text: "Lobby info"
            },
            {
              opcode: "query_lobby",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Get info about public lobby [LOBBY]",
              arguments: {
                LOBBY: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "DemoLobby"
                }
              }
            },
            {
              opcode: "init_host_mode",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Host a lobby named [LOBBY], set the peer limit to [PEERS], set password to [PASSWORD], and [CLAIMCONFIG]",
              arguments: {
                LOBBY: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "DemoLobby"
                },
                PEERS: {
                  type: Scratch2.ArgumentType.NUMBER,
                  defaultValue: 0
                },
                PASSWORD: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: ""
                },
                CLAIMCONFIG: {
                  type: Scratch2.ArgumentType.NUMBER,
                  menu: "lobbyConfigMenu",
                  defaultValue: 1
                }
              }
            },
            {
              opcode: "init_peer_mode",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Join lobby [LOBBY] with password [PASSWORD]",
              arguments: {
                LOBBY: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "DemoLobby"
                },
                PASSWORD: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: ""
                }
              }
            },
            {
              opcode: "get_client_mode",
              blockType: Scratch2.BlockType.REPORTER,
              text: "Am I a host or a peer?"
            },
            {
              opcode: "on_new_peer",
              blockType: Scratch2.BlockType.EVENT,
              text: "When I get connected to a new peer"
            },
            {
              opcode: "get_new_peer",
              blockType: Scratch2.BlockType.REPORTER,
              text: "Newest peer connected"
            },
            {
              opcode: "on_broadcast_message",
              blockType: Scratch2.BlockType.HAT,
              isEdgeActivated: false,
              text: "When I get a broadcast message in channel [CHANNEL]",
              arguments: {
                CHANNEL: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "default"
                }
              }
            },
            {
              opcode: "get_global_channel_data",
              blockType: Scratch2.BlockType.REPORTER,
              text: "Global channel [CHANNEL] data",
              arguments: {
                CHANNEL: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "default"
                }
              }
            },
            {
              opcode: "broadcast",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Broadcast global data [DATA] to all peers using channel [CHANNEL] and wait for broadcast to finish sending? [WAIT]",
              arguments: {
                DATA: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "Hello"
                },
                CHANNEL: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "default"
                },
                WAIT: {
                  type: Scratch2.ArgumentType.BOOLEAN,
                  defaultValue: false
                }
              }
            },
            {
              opcode: "on_private_message",
              blockType: Scratch2.BlockType.HAT,
              isEdgeActivated: false,
              text: "When I get a private message from peer [PEER] in channel [CHANNEL]",
              arguments: {
                CHANNEL: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "default"
                },
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                }
              }
            },
            {
              opcode: "get_private_channel_data",
              blockType: Scratch2.BlockType.REPORTER,
              text: "Private channel [CHANNEL] data from peer [PEER]",
              arguments: {
                CHANNEL: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "default"
                },
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                }
              }
            },
            {
              opcode: "send",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Send private data [DATA] to peer [PEER] using channel [CHANNEL] and wait for message to finish sending? [WAIT]",
              arguments: {
                DATA: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "Hello"
                },
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                },
                CHANNEL: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "default"
                },
                WAIT: {
                  type: Scratch2.ArgumentType.BOOLEAN,
                  defaultValue: false
                }
              }
            },
            {
              opcode: "store_private_channel_in_variable",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Store received private messages from peer [PEER]'s channel [CHANNEL] into variable [VAR]",
              arguments: {
                CHANNEL: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "default"
                },
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                },
                VAR: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "my variable"
                }
              }
            },
            {
              opcode: "make_global_networked_list",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Make list [LIST] a global networked list",
              arguments: {
                LIST: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "my list"
                }
              }
            },
            {
              opcode: "make_private_networked_list",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Make list [LIST] a private networked list with peer [PEER]",
              arguments: {
                LIST: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "my list"
                },
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                }
              }
            },
            {
              opcode: "request_mic_perms",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Request microphone access"
            },
            {
              opcode: "get_mic_perms",
              blockType: Scratch2.BlockType.BOOLEAN,
              text: "Do I have microphone access?"
            },
            {
              opcode: "is_peer_vchan_open",
              blockType: Scratch2.BlockType.BOOLEAN,
              text: "Connected to voice chat with peer [PEER]?",
              arguments: {
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                }
              }
            },
            {
              opcode: "get_mic_mute_state",
              blockType: Scratch2.BlockType.BOOLEAN,
              text: "Is my microphone with peer [PEER] muted?",
              arguments: {
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                }
              }
            },
            {
              opcode: "change_mic_state",
              blockType: Scratch2.BlockType.COMMAND,
              text: "[MICSTATE] my microphone with peer [PEER]",
              arguments: {
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                },
                MICSTATE: {
                  type: Scratch2.ArgumentType.NUMBER,
                  menu: "micStateMenu",
                  defaultValue: "0"
                }
              }
            },
            {
              opcode: "new_vchan",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Open a voice chat with peer [PEER]",
              arguments: {
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                }
              }
            },
            {
              opcode: "close_vchan",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Close voice chat with peer [PEER]",
              arguments: {
                PEER: {
                  type: Scratch2.ArgumentType.STRING,
                  defaultValue: "ID"
                }
              }
            },
            {
              opcode: "changeKeepalive",
              blockType: Scratch2.BlockType.COMMAND,
              text: "Keep signaling connection alive? [KEEPALIVE]",
              arguments: {
                KEEPALIVE: {
                  type: Scratch2.ArgumentType.BOOLEAN,
                  defaultValue: false
                }
              }
            }
          ],
          menus: {
            lobbyConfigMenu: {
              items: [
                {
                  text: "don't allow this lobby to be reclaimed",
                  value: "1"
                },
                {
                  text: "allow the server to reclaim the lobby",
                  value: "2"
                },
                {
                  text: "allow peers to reclaim the lobby",
                  value: "3"
                }
              ]
            },
            micStateMenu: {
              items: [
                {
                  text: "Mute",
                  value: "0"
                },
                {
                  text: "Unmute",
                  value: "1"
                }
              ]
            },
            channelConfig: {
              items: [
                {
                  text: "reliability/order over speed",
                  value: "1"
                },
                {
                  text: "speed over reliability/order",
                  value: "2"
                }
              ]
            }
          }
        };
      }
      changeKeepalive({ KEEPALIVE }) {
        OmegaSignalingInstance.enableKeepalive = KEEPALIVE;
        backupSettings(this.runtime);
      }
      async clOmegaProtocolMessageHandler(remotePeerId, channel, message) {
        let packet;
        try {
          packet = JSON.parse(message);
          const opcode = packet.opcode;
          const payload = packet.payload;
          console.log(`[${remotePeerId}]`, packet);
          switch (opcode) {
            case "G_MSG":
              if (!this.globalDataStorage.has(channel.label)) {
                this.globalDataStorage.set(channel.label, /* @__PURE__ */ new Map());
              }
              this.globalDataStorage.set(channel.label, payload);
              break;
            case "G_VAR":
              break;
            case "G_LIST":
              for (const target of this.runtime.targets) {
                const myList = target.lookupVariableById(
                  payload.id
                );
                if (myList == null)
                  continue;
                NetworkedScratchDataInstance.networkUpdateTracker[myList.id].current = true;
                switch (payload.method) {
                  case "set":
                    if (payload.value == "") {
                      delete myList.value[payload.index];
                    } else {
                      myList.value[payload.index] = payload.value;
                    }
                    break;
                  case "reset":
                    myList.value = payload.value;
                    break;
                  case "replace":
                    if (payload.value == "") {
                      delete myList.value[payload.index];
                    } else {
                      myList.value[payload.index] = payload.value;
                    }
                    break;
                  case "length":
                    myList.value.length = payload.value;
                    break;
                }
              }
              break;
            case "P_MSG":
              channel.dataStorage.set("pmsg", payload);
              break;
            case "P_VAR":
              break;
            case "P_LIST":
              break;
            case "RING":
              break;
            case "PICKUP":
              break;
            case "HANGUP":
              break;
          }
        } catch (error) {
          console.error(
            `Error handling peer ${remotePeerId}'s channel ${channel.label} message ${message}: ${error}`
          );
          return;
        }
      }
      initialize({ SERVER }, util) {
        if (!OmegaSignalingInstance.socket) {
          return new Promise((resolve, reject) => {
            OmegaSignalingInstance.Connect(SERVER);
            OmegaSignalingInstance.onConnect(() => {
              console.log("Connected to signaling server.");
              console.log(this);
              this.vm.runtime.startHats("cl5_on_signalling_connect");
              resolve();
            });
            OmegaSignalingInstance.onClose("auto", () => {
              console.log("Disconnected from signaling server.");
              Array.from(OmegaRTCInstance.peerConnections.keys()).forEach(
                (peer) => {
                  OmegaRTCInstance.closeVoiceConnection(peer);
                  OmegaRTCInstance.disconnectDataPeer(peer);
                }
              );
              util.startHats("cl5_on_signalling_disconnect");
              reject();
            });
            OmegaSignalingInstance.onAnticipate(async (message) => {
              const remoteUserId = message.payload.id;
              const pubKey = message.payload.pubkey;
              OmegaSignalingInstance.onPeerGone(remoteUserId, () => {
                OmegaRTCInstance.disconnectDataPeer(remoteUserId);
              });
              if (pubKey) {
                await OmegaEncryptionInstance.setSharedKeyFromPublicKey(
                  remoteUserId,
                  pubKey
                );
              }
              OmegaRTCInstance.onChannelOpen(
                remoteUserId,
                async (channel) => {
                  if (channel == "default") {
                    this.newestPeerConnected = remoteUserId;
                    util.startHats("cl5_on_new_peer");
                  }
                }
              );
            });
            OmegaSignalingInstance.onDiscover(
              async (message) => {
                const remoteUserName = message.payload.user;
                const remoteUserId = message.payload.id;
                const pubKey = message.payload.pubkey;
                let sharedKey;
                OmegaSignalingInstance.onPeerGone(remoteUserId, () => {
                  OmegaRTCInstance.disconnectDataPeer(remoteUserId);
                });
                if (pubKey) {
                  await OmegaEncryptionInstance.setSharedKeyFromPublicKey(
                    remoteUserId,
                    pubKey
                  );
                  sharedKey = OmegaEncryptionInstance.getSharedKey(remoteUserId);
                }
                const offer = await OmegaRTCInstance.createDataOffer(
                  remoteUserId,
                  remoteUserName
                );
                if (sharedKey) {
                  const { encryptedMessage, iv } = await OmegaEncryptionInstance.encryptMessage(
                    JSON.stringify(offer),
                    sharedKey
                  );
                  OmegaSignalingInstance.sendOffer(
                    remoteUserId,
                    {
                      type: 0,
                      // data
                      contents: [encryptedMessage, iv]
                    },
                    null
                  );
                } else {
                  OmegaSignalingInstance.sendOffer(
                    remoteUserId,
                    {
                      type: 0,
                      // data
                      contents: offer
                    },
                    null
                  );
                }
              }
            );
            OmegaSignalingInstance.onNewPeer(async (message) => {
              const remoteUserName = message.payload.user;
              const remoteUserId = message.payload.id;
              const pubKey = message.payload.pubkey;
              let sharedKey;
              OmegaSignalingInstance.onPeerGone(remoteUserId, () => {
                OmegaRTCInstance.disconnectDataPeer(remoteUserId);
              });
              if (pubKey) {
                await OmegaEncryptionInstance.setSharedKeyFromPublicKey(
                  remoteUserId,
                  pubKey
                );
                sharedKey = await OmegaEncryptionInstance.getSharedKey(remoteUserId);
              }
              const offer = await OmegaRTCInstance.createDataOffer(
                remoteUserId,
                remoteUserName
              );
              if (sharedKey) {
                const { encryptedMessage, iv } = await OmegaEncryptionInstance.encryptMessage(
                  JSON.stringify(offer),
                  sharedKey
                );
                OmegaSignalingInstance.sendOffer(
                  remoteUserId,
                  {
                    type: 0,
                    // data
                    contents: [encryptedMessage, iv]
                  },
                  null
                );
              } else {
                OmegaSignalingInstance.sendOffer(
                  remoteUserId,
                  {
                    type: 0,
                    // data
                    contents: offer
                  },
                  null
                );
              }
              OmegaRTCInstance.onChannelOpen(remoteUserId, async (channel) => {
                if (channel == "default") {
                  this.newestPeerConnected = remoteUserId;
                  util.startHats("cl5_on_new_peer");
                }
              });
            });
            OmegaSignalingInstance.onNewHost(async (message) => {
              const remoteUserName = message.payload.user;
              const remoteUserId = message.payload.id;
              const lobby = message.payload.lobby_id;
              const pubKey = message.payload.pubkey;
              console.log(
                `New lobby ${lobby} created by host ${remoteUserName} (${remoteUserId})`
              );
              OmegaSignalingInstance.onHostGone(remoteUserId, () => {
                OmegaRTCInstance.disconnectDataPeer(remoteUserId);
              });
              if (pubKey) {
                await OmegaEncryptionInstance.setSharedKeyFromPublicKey(
                  remoteUserId,
                  pubKey
                );
              }
              OmegaRTCInstance.onChannelOpen(remoteUserId, async (channel) => {
                if (channel == "default") {
                  this.newestPeerConnected = remoteUserId;
                  util.startHats("cl5_on_new_peer");
                }
              });
            });
            OmegaSignalingInstance.onIceCandidateReceived(
              async (message) => {
                const remoteUserId = message.origin.id;
                const sharedKey = await OmegaEncryptionInstance.getSharedKey(remoteUserId);
                const type = message.payload.type;
                let candidate = message.payload.contents;
                if (sharedKey) {
                  const encryptedMessage = candidate[0];
                  const iv = candidate[1];
                  candidate = JSON.parse(
                    await OmegaEncryptionInstance.decryptMessage(
                      encryptedMessage,
                      iv,
                      sharedKey
                    )
                  );
                }
                switch (type) {
                  case 0:
                    OmegaRTCInstance.addDataIceCandidate(remoteUserId, candidate);
                    break;
                  case 1:
                    OmegaRTCInstance.addVoiceIceCandidate(remoteUserId, candidate);
                    break;
                }
              }
            );
            OmegaSignalingInstance.onOffer(async (message) => {
              const remoteUserName = message.origin.user;
              const remoteUserId = message.origin.id;
              const sharedKey = await OmegaEncryptionInstance.getSharedKey(remoteUserId);
              let answer;
              let offer = message.payload.contents;
              const type = message.payload.type;
              if (sharedKey) {
                const encryptedMessage = offer[0];
                const iv = offer[1];
                offer = JSON.parse(
                  await OmegaEncryptionInstance.decryptMessage(
                    encryptedMessage,
                    iv,
                    sharedKey
                  )
                );
              }
              switch (type) {
                case 0:
                  answer = await OmegaRTCInstance.createDataAnswer(
                    remoteUserId,
                    remoteUserName,
                    offer
                  );
                  break;
                case 1:
                  answer = await OmegaRTCInstance.createVoiceAnswer(
                    remoteUserId,
                    remoteUserName,
                    offer
                  );
                  break;
              }
              if (sharedKey) {
                const { encryptedMessage, iv } = await OmegaEncryptionInstance.encryptMessage(
                  JSON.stringify(answer),
                  sharedKey
                );
                OmegaSignalingInstance.sendAnswer(
                  remoteUserId,
                  {
                    type,
                    contents: [encryptedMessage, iv]
                  },
                  null
                );
              } else {
                OmegaSignalingInstance.sendAnswer(
                  remoteUserId,
                  {
                    type,
                    contents: answer
                  },
                  null
                );
              }
              OmegaRTCInstance.onChannelMessage(
                remoteUserId,
                async (message2, channel) => {
                  await this.clOmegaProtocolMessageHandler(
                    remoteUserId,
                    channel,
                    message2
                  );
                }
              );
              OmegaRTCInstance.onIceCandidate(
                remoteUserId,
                async (candidate) => {
                  if (sharedKey) {
                    const { encryptedMessage, iv } = await OmegaEncryptionInstance.encryptMessage(
                      JSON.stringify(candidate),
                      sharedKey
                    );
                    OmegaSignalingInstance.sendIceCandidate(
                      remoteUserId,
                      {
                        type,
                        contents: [encryptedMessage, iv]
                      },
                      null
                    );
                  } else {
                    OmegaSignalingInstance.sendIceCandidate(
                      remoteUserId,
                      {
                        type,
                        contents: candidate
                      },
                      null
                    );
                  }
                  OmegaRTCInstance.removeIceCandidate(remoteUserId, candidate);
                }
              );
              OmegaRTCInstance.onIceGatheringDone(remoteUserId, () => {
                OmegaRTCInstance.iceCandidates[remoteUserId].forEach(
                  async (candidate) => {
                    if (sharedKey) {
                      const { encryptedMessage, iv } = await OmegaEncryptionInstance.encryptMessage(
                        JSON.stringify(candidate),
                        sharedKey
                      );
                      OmegaSignalingInstance.sendIceCandidate(
                        remoteUserId,
                        {
                          type,
                          contents: [encryptedMessage, iv]
                        },
                        null
                      );
                    } else {
                      OmegaSignalingInstance.sendIceCandidate(
                        remoteUserId,
                        {
                          type,
                          contents: candidate
                        },
                        null
                      );
                    }
                    OmegaRTCInstance.removeIceCandidate(remoteUserId, candidate);
                  }
                );
              });
            });
            OmegaSignalingInstance.onAnswer(async (message) => {
              const remoteUserId = message.origin.id;
              const sharedKey = OmegaEncryptionInstance.getSharedKey(remoteUserId);
              const type = message.payload.type;
              let answer = message.payload.contents;
              if (sharedKey) {
                const encryptedMessage = answer[0];
                const iv = answer[1];
                answer = JSON.parse(
                  await OmegaEncryptionInstance.decryptMessage(
                    encryptedMessage,
                    iv,
                    sharedKey
                  )
                );
              }
              switch (type) {
                case 0:
                  await OmegaRTCInstance.handleDataAnswer(remoteUserId, answer);
                  break;
                case 1:
                  await OmegaRTCInstance.handleVoiceAnswer(remoteUserId, answer);
                  break;
              }
              OmegaRTCInstance.onChannelMessage(
                remoteUserId,
                async (message2, channel) => {
                  await this.clOmegaProtocolMessageHandler(
                    remoteUserId,
                    channel,
                    message2
                  );
                }
              );
              OmegaRTCInstance.onIceCandidate(remoteUserId, async (candidate) => {
                if (sharedKey) {
                  const { encryptedMessage, iv } = await OmegaEncryptionInstance.encryptMessage(
                    JSON.stringify(candidate),
                    sharedKey
                  );
                  OmegaSignalingInstance.sendIceCandidate(
                    remoteUserId,
                    {
                      type,
                      contents: [encryptedMessage, iv]
                    },
                    null
                  );
                } else {
                  OmegaSignalingInstance.sendIceCandidate(
                    remoteUserId,
                    {
                      type,
                      contents: candidate
                    },
                    null
                  );
                }
                OmegaRTCInstance.removeIceCandidate(remoteUserId, candidate);
              });
              OmegaRTCInstance.onIceGatheringDone(remoteUserId, () => {
                OmegaRTCInstance.iceCandidates[remoteUserId].forEach(
                  async (candidate) => {
                    if (sharedKey) {
                      const { encryptedMessage, iv } = await OmegaEncryptionInstance.encryptMessage(
                        JSON.stringify(candidate),
                        sharedKey
                      );
                      OmegaSignalingInstance.sendIceCandidate(
                        remoteUserId,
                        {
                          type,
                          contents: [encryptedMessage, iv]
                        },
                        null
                      );
                    } else {
                      OmegaSignalingInstance.sendIceCandidate(
                        remoteUserId,
                        {
                          type,
                          contents: candidate
                        },
                        null
                      );
                    }
                    OmegaRTCInstance.removeIceCandidate(remoteUserId, candidate);
                  }
                );
              });
            });
          });
        }
      }
      query_lobbies() {
        return new Promise((resolve, reject) => {
          if (!OmegaSignalingInstance.socket) {
            console.warn("Signaling server not connected");
            reject();
            return;
          }
          OmegaSignalingInstance.sendGetLobbyList(null);
          OmegaSignalingInstance.onLobbyList(() => resolve());
        });
      }
      lobby_list() {
        return makeValueSafeForScratch(OmegaSignalingInstance.lobbyList);
      }
      query_lobby({ LOBBY }) {
        return new Promise((resolve, reject) => {
          if (!OmegaSignalingInstance.socket) {
            console.warn("Signaling server not connected");
            reject();
            return;
          }
          OmegaSignalingInstance.sendGetLobbyInfo(LOBBY, null);
          OmegaSignalingInstance.onLobbyInfo(() => resolve());
        });
      }
      lobby_info() {
        return makeValueSafeForScratch(OmegaSignalingInstance.lobbyInfo);
      }
      init_host_mode({ LOBBY, PEERS, PASSWORD, CLAIMCONFIG }) {
        return new Promise(async (resolve, reject) => {
          if (!OmegaSignalingInstance.socket) {
            console.warn("Signaling server not connected");
            reject();
            return;
          }
          const max_peers = parseInt(PEERS);
          if (isNaN(max_peers)) {
            console.warn("Desired peers value is not a number.");
            reject();
            return;
          }
          let allow_host_reclaim = false;
          let allow_peers_to_claim_host = false;
          switch (CLAIMCONFIG) {
            case 1:
              allow_host_reclaim = false;
              allow_peers_to_claim_host = false;
              break;
            case 2:
              allow_host_reclaim = true;
              allow_peers_to_claim_host = false;
              break;
            case 3:
              allow_host_reclaim = true;
              allow_peers_to_claim_host = true;
              break;
          }
          OmegaSignalingInstance.hostMode(
            LOBBY,
            allow_host_reclaim,
            allow_peers_to_claim_host,
            max_peers,
            PASSWORD,
            await OmegaEncryptionInstance.exportPublicKey(),
            null
          );
          OmegaSignalingInstance.onHostModeConfig(() => resolve());
          OmegaSignalingInstance.onModeConfigFailure(() => reject());
        });
      }
      async init_peer_mode({ LOBBY, PASSWORD }) {
        return new Promise(async (resolve, reject) => {
          if (!OmegaSignalingInstance.socket) {
            console.warn("Signaling server not connected");
            reject();
            return;
          }
          OmegaSignalingInstance.peerMode(
            LOBBY,
            PASSWORD,
            await OmegaEncryptionInstance.exportPublicKey(),
            null
          );
          OmegaSignalingInstance.onPeerModeConfig(() => resolve());
          OmegaSignalingInstance.onModeConfigFailure(() => reject());
        });
      }
      send({ DATA, PEER, CHANNEL, WAIT }) {
        return OmegaRTCInstance.sendData(PEER, CHANNEL, "P_MSG", DATA, WAIT);
      }
      broadcast({ DATA, CHANNEL, WAIT }) {
        return OmegaRTCInstance.broadcastData(CHANNEL, "G_MSG", DATA, WAIT);
      }
      disconnect_peer({ PEER }) {
        OmegaRTCInstance.disconnectDataPeer(PEER);
      }
      leave() {
        if (!OmegaSignalingInstance.socket)
          return;
        return new Promise((resolve) => {
          OmegaSignalingInstance.Disconnect();
          OmegaSignalingInstance.onClose("manual", () => resolve());
        });
      }
      is_signalling_connected() {
        if (!OmegaSignalingInstance.socket)
          return false;
        return OmegaSignalingInstance.socket.readyState === 1;
      }
      is_signaling_auth_success() {
        return OmegaSignalingInstance.state.authenticated;
      }
      my_ID() {
        return OmegaSignalingInstance.state.id;
      }
      my_Username() {
        return OmegaSignalingInstance.state.user;
      }
      get_peers() {
        return makeValueSafeForScratch(OmegaRTCInstance.getPeers());
      }
      authenticate({ TOKEN }) {
        if (!OmegaSignalingInstance.socket) {
          console.warn("Signaling server not connected");
          return;
        }
        OmegaSignalingInstance.authenticateWithToken(TOKEN, null);
      }
      // Request microphone permission
      async request_mic_perms() {
        this.hasMicPerms = false;
        try {
          await navigator.mediaDevices.getUserMedia({ audio: true });
          this.hasMicPerms = true;
        } catch (e) {
          console.warn(`Failed to get microphone permission. ${e}`);
          return;
        }
      }
      get_mic_perms() {
        return this.hasMicPerms;
      }
      new_dchan({ CHANNEL, PEER, ORDERED }) {
        if (!OmegaSignalingInstance.socket)
          return;
        if (!OmegaRTCInstance.doesPeerExist(PEER)) {
          console.warn(`Peer ${PEER} not found.`);
          return;
        }
        if (OmegaRTCInstance.getPeerChannels(PEER).includes(CHANNEL)) {
          console.warn(`Channel ${CHANNEL} with peer ${PEER} already open.`);
          return;
        }
        OmegaRTCInstance.createChannel(
          PEER,
          CHANNEL,
          ORDERED == 1
          // channelIdCounter
        );
      }
      async new_vchan({ PEER }) {
        await OmegaRTCInstance.createVoiceConnection(PEER);
      }
      change_mic_state({ MICSTATE, PEER }) {
        OmegaRTCInstance.changeMicState(PEER, MICSTATE == 1);
      }
      is_peer_vchan_open({ PEER }) {
        return OmegaRTCInstance.isVoiceConnectionOpen(PEER);
      }
      get_mic_mute_state({ PEER }) {
        return OmegaRTCInstance.isVoiceConnectionMuted(PEER);
      }
      close_vchan({ PEER }) {
        OmegaRTCInstance.closeVoiceConnection(PEER);
      }
      close_dchan({ CHANNEL, PEER }) {
        if (CHANNEL == "default") {
          console.warn("You may not close the default data channel.");
          return;
        }
        if (!OmegaRTCInstance.doesPeerExist(PEER)) {
          console.warn(`Peer ${PEER} not found.`);
          return;
        }
        if (!OmegaRTCInstance.dataChannels.get(PEER).get(CHANNEL)) {
          console.warn(`Channel ${CHANNEL} does not exist for peer ${PEER}`);
          return;
        }
        OmegaRTCInstance.dataChannels.get(PEER).get(CHANNEL).close();
      }
      get_peer_channels({ PEER }) {
        return makeValueSafeForScratch(OmegaRTCInstance.getPeerChannels(PEER));
      }
      is_peer_connected({ PEER }) {
        return OmegaRTCInstance.doesPeerExist(PEER);
      }
      get_global_channel_data({ CHANNEL }) {
        if (!this.globalDataStorage.has(CHANNEL))
          return "";
        return makeValueSafeForScratch(this.globalDataStorage.get(CHANNEL));
      }
      get_private_channel_data({ CHANNEL, PEER }) {
        if (!OmegaRTCInstance.doesPeerExist(PEER))
          return "";
        if (!OmegaRTCInstance.doesPeerChannelExist(PEER, CHANNEL))
          return "";
        return makeValueSafeForScratch(
          OmegaRTCInstance.dataChannels.get(PEER).get(CHANNEL).dataStorage.get("pmsg")
        );
      }
      /*
      store_private_channel_in_variable(
        { CHANNEL, PEER, VAR },
        util: VM.BlockUtility
      ): void {
        // TODO
      } */
      get_client_mode() {
        if (OmegaSignalingInstance.state.mode == 1) {
          return "host";
        } else if (OmegaSignalingInstance.state.mode == 2) {
          return "peer";
        } else
          return "";
      }
      // @ts-expect-error Function is temporarily disabled
      make_private_networked_list({ LIST, PEER }, util) {
        return;
      }
      make_global_networked_list({ LIST }, util) {
        const target = util.target;
        const list = target.lookupVariableByNameAndType(LIST, "list");
        if (!list) {
          console.warn(`List ${LIST} not found.`);
          return;
        }
        NetworkedScratchDataInstance.makeNetworkedList(list);
        backupSettings(this.runtime);
      }
      // @ts-expect-error Function is not yet implemented
      on_private_message({ PEER, CHANNEL }) {
      }
      // @ts-expect-error Function is not yet implemented
      on_broadcast_message({ CHANNEL }) {
      }
      get_new_peer() {
        return this.newestPeerConnected;
      }
    }
    Scratch2.vm.runtime.on("BEFORE_EXECUTE", () => {
      NetworkedScratchDataInstance.update(Scratch2.vm.runtime);
    });
    Scratch2.vm.runtime.on(
      "PROJECT_LOADED",
      () => restoreSettings(Scratch2.vm.runtime)
    );
    Scratch2.vm.runtime.on("PROJECT_STOP_ALL", () => {
      if (!OmegaSignalingInstance.socket)
        return;
      return new Promise((resolve) => {
        Array.from(OmegaRTCInstance.peerConnections.keys()).forEach((peer) => {
          OmegaRTCInstance.closeVoiceConnection(peer);
          OmegaRTCInstance.disconnectDataPeer(peer);
        });
        OmegaSignalingInstance.Disconnect();
        OmegaSignalingInstance.onClose("manual", () => resolve());
      });
    });
    if (Scratch2.vm?.runtime) {
      Scratch2.extensions.register(new CloudLink5(Scratch2.vm));
    } else {
      throw new Error(
        "This extension is not supported in this Scratch Mod because it does not expose a `vm` property."
      );
    }
  })(Scratch);
})();
